<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Design Diagrams Viewer</title>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#90EE90',
                primaryTextColor: '#000',
                primaryBorderColor: '#7FFF00',
                lineColor: '#333',
                secondaryColor: '#FFE4B5',
                tertiaryColor: '#E6E6FA'
            }
        });
    </script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 40px;
            border-left: 4px solid #4CAF50;
            padding-left: 15px;
        }
        .diagram-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .mermaid {
            text-align: center;
            background: white;
        }
        .note {
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .toc {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .toc a {
            color: #4CAF50;
            text-decoration: none;
        }
        .toc a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>üèóÔ∏è System Design Diagrams</h1>
    
    <div class="note">
        <strong>üìä Viewing Instructions:</strong> All diagrams below are rendered using Mermaid.js. 
        If diagrams don't appear, check your browser console for errors or try refreshing the page.
    </div>

    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            <li><a href="#system-architecture">System Architecture Diagram</a></li>
            <li><a href="#architecture-layers">Architecture Layers</a></li>
            <li><a href="#component-diagram">Detailed Component Diagram</a></li>
            <li><a href="#component-responsibilities">Component Responsibilities</a></li>
            <li><a href="#cache-hit">Cache Hit Flow</a></li>
            <li><a href="#cache-miss">Cache Miss Flow</a></li>
            <li><a href="#cache-invalidation">Cache Invalidation Flow</a></li>
            <li><a href="#cluster-topology">Cluster Topology</a></li>
            <li><a href="#cluster-discovery">Cluster Discovery</a></li>
            <li><a href="#message-flow">Message Flow in Cluster</a></li>
            <li><a href="#single-node">Single Node Deployment</a></li>
            <li><a href="#multi-node">Multi-Node Cluster Deployment</a></li>
            <li><a href="#network-architecture">Network Architecture</a></li>
            <li><a href="#request-flow">Complete Request Flow</a></li>
            <li><a href="#cache-storage">Cache Storage Structure</a></li>
            <li><a href="#cache-operation">Complete Cache Operation Sequence</a></li>
            <li><a href="#cluster-startup">Cluster Startup Sequence</a></li>
            <li><a href="#cache-replication">Cache Replication Sequence</a></li>
            <li><a href="#latency">Latency Breakdown</a></li>
            <li><a href="#throughput">Throughput Architecture</a></li>
            <li><a href="#security">Security Layers</a></li>
            <li><a href="#metrics">Metrics Flow</a></li>
        </ul>
    </div>

    <h2 id="system-architecture">System Architecture Diagram</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph TB
    subgraph "Client Applications"
        APP1[Application 1<br/>JVM Instance]
        APP2[Application 2<br/>JVM Instance]
        APP3[Application N<br/>JVM Instance]
    end
    
    subgraph "Cache System Node 1"
        API1[REST API<br/>Port 8080]
        CORE1[Cache Core<br/>CacheService]
        CLUSTER1[Cluster Coordinator]
        MEM1[In-Memory Cache<br/>ConcurrentHashMap]
    end
    
    subgraph "Cache System Node 2"
        API2[REST API<br/>Port 8081]
        CORE2[Cache Core<br/>CacheService]
        CLUSTER2[Cluster Coordinator]
        MEM2[In-Memory Cache<br/>ConcurrentHashMap]
    end
    
    subgraph "Cache System Node N"
        APIN[REST API<br/>Port 808N]
        COREN[Cache Core<br/>CacheService]
        CLUSTERN[Cluster Coordinator]
        MEMN[In-Memory Cache<br/>ConcurrentHashMap]
    end
    
    subgraph "External Systems"
        DB[(Database)]
        METRICS[Prometheus<br/>Metrics]
    end
    
    APP1 -->|HTTP/REST| API1
    APP2 -->|HTTP/REST| API2
    APP3 -->|HTTP/REST| APIN
    
    API1 --> CORE1
    API2 --> CORE2
    APIN --> COREN
    
    CORE1 --> MEM1
    CORE2 --> MEM2
    COREN --> MEMN
    
    CORE1 -->|Load on Miss| DB
    CORE2 -->|Load on Miss| DB
    COREN -->|Load on Miss| DB
    
    CLUSTER1 <-->|TCP Port 9090| CLUSTER2
    CLUSTER2 <-->|TCP Port 9091| CLUSTERN
    CLUSTER1 <-->|TCP Port 909N| CLUSTERN
    
    CORE1 --> CLUSTER1
    CORE2 --> CLUSTER2
    COREN --> CLUSTERN
    
    CORE1 --> METRICS
    CORE2 --> METRICS
    COREN --> METRICS
        </div>
    </div>

    <h2 id="architecture-layers">Architecture Layers</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph TD
    subgraph "Presentation Layer"
        REST[REST API Controllers<br/>CacheController, ClusterController]
        UI[Web Dashboard<br/>HTML/CSS/JS]
    end
    
    subgraph "Service Layer"
        CS[CacheService<br/>Business Logic]
        CC[ClusterCoordinator<br/>Cluster Management]
    end
    
    subgraph "Core Layer"
        CM[CacheManager<br/>In-Memory Storage]
        MS[MessageSender<br/>Network Communication]
        MR[MessageReceiver<br/>Network Communication]
        CMEM[ClusterMembership<br/>Peer Discovery]
    end
    
    subgraph "Infrastructure Layer"
        METRICS[Metrics<br/>Micrometer]
        HEALTH[Health Checks<br/>Actuator]
        SEC[Security<br/>Spring Security]
        CONFIG[Configuration<br/>YAML Properties]
    end
    
    REST --> CS
    UI --> REST
    CS --> CM
    CS --> CC
    CC --> MS
    CC --> MR
    CC --> CMEM
    CS --> METRICS
    CS --> HEALTH
    REST --> SEC
    CS --> CONFIG
        </div>
    </div>

    <h2 id="component-diagram">Detailed Component Diagram</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph LR
    subgraph "API Layer"
        CC[CacheController<br/>REST Endpoints]
        CLUSTERC[ClusterController<br/>Cluster Status]
        WC[WebController<br/>Dashboard]
    end
    
    subgraph "Service Layer"
        CS[CacheServiceImpl<br/>Business Logic]
        ICM[InMemoryCacheManager<br/>Storage Engine]
    end
    
    subgraph "Cluster Layer"
        COORD[ClusterCoordinator<br/>Orchestration]
        MEMBERSHIP[ClusterMembership<br/>Peer Management]
        MSENDER[MessageSender<br/>Outbound Messages]
        MRECEIVER[MessageReceiver<br/>Inbound Messages]
    end
    
    subgraph "Core Data Structures"
        CACHE[ConcurrentHashMap<br/>Cache Storage]
        LOCKS[ReentrantLock<br/>Per-Key Locks]
        FUTURES[CompletableFuture<br/>Async Loading]
    end
    
    subgraph "Supporting Components"
        METRICS[CacheMetrics<br/>Observability]
        SERIAL[SerializationUtil<br/>Kryo Serialization]
        HEALTH[CacheHealthIndicator<br/>Health Checks]
    end
    
    CC --> CS
    CLUSTERC --> COORD
    WC --> CS
    CS --> ICM
    CS --> COORD
    CS --> METRICS
    ICM --> CACHE
    ICM --> LOCKS
    ICM --> FUTURES
    COORD --> MEMBERSHIP
    COORD --> MSENDER
    MRECEIVER --> COORD
    MSENDER --> SERIAL
    MRECEIVER --> SERIAL
    CS --> HEALTH
        </div>
    </div>

    <h2 id="cache-hit">Cache Hit Flow</h2>
    <div class="diagram-container">
        <div class="mermaid">
sequenceDiagram
    participant Client
    participant CacheService
    participant CacheManager
    participant CacheStorage
    
    Client->>CacheService: getOrLoad("issue", "issue:123", loader)
    CacheService->>CacheManager: get("issue", "issue:123")
    CacheManager->>CacheStorage: lookup("issue:123")
    CacheStorage-->>CacheManager: CacheEntry (found)
    CacheManager->>CacheManager: Check TTL (valid)
    CacheManager-->>CacheService: Optional<Issue> (present)
    CacheService->>CacheService: Record Hit Metric
    CacheService-->>Client: Issue (from cache, <2ms)
    
    Note over CacheService,CacheStorage: Cache Hit - No Database Query
        </div>
    </div>

    <h2 id="cache-miss">Cache Miss Flow (with Thundering Herd Prevention)</h2>
    <div class="diagram-container">
        <div class="mermaid">
sequenceDiagram
    participant Client1
    participant Client2
    participant Client3
    participant CacheService
    participant LockManager
    participant CacheManager
    participant Database
    
    par Concurrent Requests
        Client1->>CacheService: getOrLoad("issue", "issue:123", loader)
        Client2->>CacheService: getOrLoad("issue", "issue:123", loader)
        Client3->>CacheService: getOrLoad("issue", "issue:123", loader)
    end
    
    CacheService->>CacheManager: get("issue", "issue:123")
    CacheManager-->>CacheService: Optional.empty() (miss)
    
    CacheService->>LockManager: acquireLock("issue:123")
    LockManager-->>CacheService: Lock acquired (Client1)
    LockManager-->>CacheService: Wait (Client2)
    LockManager-->>CacheService: Wait (Client3)
    
    CacheService->>CacheService: Check if loaded by another thread
    CacheService->>Database: loader.get() - Load from DB
    Database-->>CacheService: Issue data (~300ms)
    
    CacheService->>CacheManager: put("issue", "issue:123", issue)
    CacheService->>LockManager: releaseLock("issue:123")
    
    LockManager-->>CacheService: Lock released
    CacheService->>CacheService: Notify waiting threads
    CacheService-->>Client1: Issue (from DB, ~300ms)
    CacheService-->>Client2: Issue (from cache, <2ms)
    CacheService-->>Client3: Issue (from cache, <2ms)
    
    Note over Client1,Client3: Only ONE database query executed
        </div>
    </div>

    <h2 id="cache-invalidation">Cache Invalidation Flow</h2>
    <div class="diagram-container">
        <div class="mermaid">
sequenceDiagram
    participant Client
    participant CacheService
    participant CacheManager
    participant ClusterCoordinator
    participant MessageSender
    participant PeerNode1
    participant PeerNode2
    
    Client->>CacheService: invalidate("issue", "issue:123")
    CacheService->>CacheManager: invalidate("issue", "issue:123")
    CacheManager->>CacheManager: Remove from local cache
    CacheService->>CacheService: Record invalidation metric
    
    CacheService->>ClusterCoordinator: Should replicate?
    ClusterCoordinator-->>CacheService: Yes (INVALIDATE mode)
    
    CacheService->>ClusterCoordinator: Get active peers
    ClusterCoordinator-->>CacheService: [peer1, peer2]
    
    par Async Invalidation
        CacheService->>MessageSender: sendInvalidation(peer1, message)
        MessageSender->>PeerNode1: TCP InvalidationMessage
        PeerNode1-->>MessageSender: ACK
        MessageSender-->>CacheService: Success
    and
        CacheService->>MessageSender: sendInvalidation(peer2, message)
        MessageSender->>PeerNode2: TCP InvalidationMessage
        PeerNode2-->>MessageSender: ACK
        MessageSender-->>CacheService: Success
    end
    
    CacheService-->>Client: Invalidation complete
        </div>
    </div>

    <h2 id="cluster-topology">Cluster Topology</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph TB
    subgraph "Cluster Network"
        NODE1[Node 1<br/>localhost:8080<br/>Comm: 9090]
        NODE2[Node 2<br/>localhost:8081<br/>Comm: 9091]
        NODE3[Node 3<br/>localhost:8082<br/>Comm: 9092]
        NODE4[Node 4<br/>localhost:8083<br/>Comm: 9093]
        NODE5[Node 5<br/>localhost:8084<br/>Comm: 9094]
    end
    
    NODE1 <-->|TCP 9090‚Üî9091| NODE2
    NODE2 <-->|TCP 9091‚Üî9092| NODE3
    NODE3 <-->|TCP 9092‚Üî9093| NODE4
    NODE4 <-->|TCP 9093‚Üî9094| NODE5
    NODE1 <-->|TCP 9090‚Üî9092| NODE3
    NODE1 <-->|TCP 9090‚Üî9093| NODE4
    NODE2 <-->|TCP 9091‚Üî9094| NODE5
    
    style NODE1 fill:#e1f5ff
    style NODE2 fill:#e1f5ff
    style NODE3 fill:#e1f5ff
    style NODE4 fill:#e1f5ff
    style NODE5 fill:#e1f5ff
        </div>
    </div>

    <h2 id="cluster-discovery">Cluster Discovery and Membership</h2>
    <div class="diagram-container">
        <div class="mermaid">
stateDiagram-v2
    [*] --> Starting: Application Start
    Starting --> Discovering: Load Configuration
    Discovering --> StaticDiscovery: Type: static
    Discovering --> MulticastDiscovery: Type: multicast
    
    StaticDiscovery --> Connecting: Connect to Peers
    MulticastDiscovery --> Connecting: Discover Peers
    
    Connecting --> Connected: All Peers Connected
    Connected --> Heartbeat: Start Heartbeat
    
    Heartbeat --> Heartbeat: Send Heartbeat (5s)
    Heartbeat --> PeerDown: Timeout (15s)
    Heartbeat --> PeerUp: Peer Recovered
    
    PeerDown --> Heartbeat: Retry Connection
    PeerUp --> Heartbeat: Resume Heartbeat
    
    Heartbeat --> [*]: Shutdown
        </div>
    </div>

    <h2 id="message-flow">Message Flow in Cluster</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph LR
    subgraph "Node A (Writer)"
        CS1[CacheService]
        CC1[ClusterCoordinator]
        MS1[MessageSender]
    end
    
    subgraph "Network"
        TCP[TCP Socket<br/>Port 9090]
    end
    
    subgraph "Node B (Receiver)"
        MR2[MessageReceiver]
        CC2[ClusterCoordinator]
        CM2[CacheManager]
    end
    
    subgraph "Node C (Receiver)"
        MR3[MessageReceiver]
        CC3[ClusterCoordinator]
        CM3[CacheManager]
    end
    
    CS1 -->|1. invalidate| CC1
    CC1 -->|2. Get Peers| CC1
    CC1 -->|3. Create Message| MS1
    
    MS1 -->|4. Serialize| TCP
    TCP -->|5. Send| MR2
    TCP -->|5. Send| MR3
    
    MR2 -->|6. Deserialize| CC2
    MR3 -->|6. Deserialize| CC3
    
    CC2 -->|7. Process| CM2
    CC3 -->|7. Process| CM3
    
    CM2 -->|8. Invalidate| CM2
    CM3 -->|8. Invalidate| CM3
        </div>
    </div>

    <h2 id="single-node">Single Node Deployment</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph TB
    subgraph "Application Server"
        JVM[JVM Process]
        APP[Spring Boot App<br/>Port 8080]
        CACHE[In-Memory Cache<br/>No Cluster]
    end
    
    subgraph "Client Applications"
        CLIENT1[Service 1]
        CLIENT2[Service 2]
    end
    
    subgraph "External"
        DB[(Database)]
        METRICS[Prometheus]
    end
    
    CLIENT1 -->|HTTP| APP
    CLIENT2 -->|HTTP| APP
    APP --> CACHE
    APP -->|Load on Miss| DB
    APP -->|Metrics| METRICS
    
    style APP fill:#90EE90
    style CACHE fill:#FFE4B5
        </div>
    </div>

    <h2 id="multi-node">Multi-Node Cluster Deployment</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph TB
    subgraph "Server 1"
        JVM1[JVM 1]
        APP1[Cache App<br/>:8080]
        CACHE1[Local Cache]
        COMM1[Comm :9090]
    end
    
    subgraph "Server 2"
        JVM2[JVM 2]
        APP2[Cache App<br/>:8081]
        CACHE2[Local Cache]
        COMM2[Comm :9091]
    end
    
    subgraph "Server 3"
        JVM3[JVM 3]
        APP3[Cache App<br/>:8082]
        CACHE3[Local Cache]
        COMM3[Comm :9092]
    end
    
    subgraph "Load Balancer"
        LB[HAProxy/Nginx<br/>:80]
    end
    
    subgraph "Clients"
        CLIENT[Client Apps]
    end
    
    subgraph "External"
        DB[(Database)]
        PROM[Prometheus]
    end
    
    CLIENT --> LB
    LB --> APP1
    LB --> APP2
    LB --> APP3
    
    APP1 --> CACHE1
    APP2 --> CACHE2
    APP3 --> CACHE3
    
    COMM1 <-->|TCP| COMM2
    COMM2 <-->|TCP| COMM3
    COMM1 <-->|TCP| COMM3
    
    APP1 --> DB
    APP2 --> DB
    APP3 --> DB
    
    APP1 --> PROM
    APP2 --> PROM
    APP3 --> PROM
    
    style APP1 fill:#90EE90
    style APP2 fill:#90EE90
    style APP3 fill:#90EE90
    style LB fill:#87CEEB
        </div>
    </div>

    <h2 id="network-architecture">Network Architecture</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph TB
    subgraph "Client Network"
        CLIENT1[Client 1]
        CLIENT2[Client 2]
    end
    
    subgraph "Application Network"
        subgraph "Node 1"
            HTTP1[HTTP :8080]
            COMM1[Comm :9090]
        end
        subgraph "Node 2"
            HTTP2[HTTP :8081]
            COMM2[Comm :9091]
        end
        subgraph "Node 3"
            HTTP3[HTTP :8082]
            COMM3[Comm :9092]
        end
    end
    
    subgraph "Management Network"
        METRICS[Prometheus :9090]
        GRAFANA[Grafana :3000]
    end
    
    CLIENT1 --> HTTP1
    CLIENT1 --> HTTP2
    CLIENT2 --> HTTP3
    
    COMM1 <--> COMM2
    COMM2 <--> COMM3
    COMM1 <--> COMM3
    
    HTTP1 --> METRICS
    HTTP2 --> METRICS
    HTTP3 --> METRICS
    METRICS --> GRAFANA
    
    style HTTP1 fill:#FFE4B5
    style HTTP2 fill:#FFE4B5
    style HTTP3 fill:#FFE4B5
    style COMM1 fill:#E6E6FA
    style COMM2 fill:#E6E6FA
    style COMM3 fill:#E6E6FA
        </div>
    </div>

    <h2 id="request-flow">Complete Request Flow</h2>
    <div class="diagram-container">
        <div class="mermaid">
flowchart TD
    START([Client Request]) --> CHECK{Request Type}
    
    CHECK -->|GET| GET_FLOW[GET Flow]
    CHECK -->|PUT| PUT_FLOW[PUT Flow]
    CHECK -->|INVALIDATE| INVALIDATE_FLOW[INVALIDATE Flow]
    
    GET_FLOW --> CACHE_CHECK{In Cache?}
    CACHE_CHECK -->|Yes| TTL_CHECK{TTL Valid?}
    TTL_CHECK -->|Yes| RETURN_HIT[Return Cached Value<br/><2ms]
    TTL_CHECK -->|No| EVICT[Evict Entry]
    CACHE_CHECK -->|No| LOAD[Load from Database]
    
    LOAD --> LOCK{Lock Acquired?}
    LOCK -->|Yes| DB_QUERY[Query Database<br/>~300ms]
    LOCK -->|No| WAIT[Wait for Loader]
    WAIT --> RETURN_MISS[Return Loaded Value]
    
    DB_QUERY --> CACHE_STORE[Store in Cache]
    CACHE_STORE --> RETURN_MISS
    EVICT --> LOAD
    
    PUT_FLOW --> VALIDATE[Validate Input]
    VALIDATE --> STORE[Store in Cache]
    STORE --> REPLICATE{Replication Mode?}
    REPLICATE -->|INVALIDATE| SEND_INVALIDATE[Send Invalidation to Peers]
    REPLICATE -->|REPLICATE| SEND_REPLICATE[Send Replication to Peers]
    REPLICATE -->|NONE| SKIP[Skip Replication]
    SEND_INVALIDATE --> RETURN_SUCCESS[Return Success]
    SEND_REPLICATE --> RETURN_SUCCESS
    SKIP --> RETURN_SUCCESS
    
    INVALIDATE_FLOW --> REMOVE_LOCAL[Remove from Local Cache]
    REMOVE_LOCAL --> SEND_INVALIDATE
    
    RETURN_HIT --> METRICS[Record Metrics]
    RETURN_MISS --> METRICS
    RETURN_SUCCESS --> METRICS
    METRICS --> END([Response])
        </div>
    </div>

    <h2 id="cache-storage">Cache Storage Structure</h2>
    <div class="diagram-container">
        <div class="mermaid">
classDiagram
    class CacheService {
        +getOrLoad()
        +put()
        +invalidate()
        +getStats()
    }
    
    class InMemoryCacheManager {
        -Map~String, Cache~ caches
        -Map~String, ReentrantLock~ locks
        -Map~String, CompletableFuture~ loaders
        +get()
        +put()
        +invalidate()
        +evict()
    }
    
    class Cache {
        -String name
        -CacheConfiguration config
        -ConcurrentHashMap~String, CacheEntry~ entries
        -long hits
        -long misses
        +get()
        +put()
        +invalidate()
        +evictLRU()
        +evictLFU()
    }
    
    class CacheEntry {
        -Object value
        -Instant createdAt
        -Instant expiresAt
        -long accessCount
        -Instant lastAccessed
        +isExpired()
        +getValue()
    }
    
    class CacheConfiguration {
        +Duration ttl
        +EvictionPolicy policy
        +int maxEntries
        +long memoryCap
        +ReplicationMode replicationMode
    }
    
    CacheService --> InMemoryCacheManager
    InMemoryCacheManager --> Cache
    Cache --> CacheEntry
    Cache --> CacheConfiguration
        </div>
    </div>

    <h2 id="cache-operation">Complete Cache Operation Sequence</h2>
    <div class="diagram-container">
        <div class="mermaid">
sequenceDiagram
    participant Client
    participant REST API
    participant CacheService
    participant CacheManager
    participant ClusterCoordinator
    participant MessageSender
    participant Peer Node
    participant Database
    participant Metrics
    
    Client->>REST API: GET /api/cache/issue/keys/issue:123
    REST API->>CacheService: getOrLoad("issue", "issue:123", loader)
    
    CacheService->>CacheManager: get("issue", "issue:123")
    CacheManager-->>CacheService: Optional.empty() (miss)
    
    CacheService->>CacheService: acquireLock("issue:123")
    CacheService->>Database: loader.get() - Load Issue
    Database-->>CacheService: Issue data
    
    CacheService->>CacheManager: put("issue", "issue:123", issue)
    CacheManager->>CacheManager: Store in ConcurrentHashMap
    
    CacheService->>ClusterCoordinator: Should replicate?
    ClusterCoordinator-->>CacheService: Yes (INVALIDATE mode)
    
    CacheService->>MessageSender: sendInvalidation(peer, message)
    MessageSender->>MessageSender: Serialize with Kryo
    MessageSender->>Peer Node: TCP InvalidationMessage
    Peer Node-->>MessageSender: ACK
    
    CacheService->>Metrics: recordHit() / recordMiss()
    CacheService-->>REST API: Issue
    REST API-->>Client: 200 OK + Issue JSON
        </div>
    </div>

    <h2 id="cluster-startup">Cluster Startup Sequence</h2>
    <div class="diagram-container">
        <div class="mermaid">
sequenceDiagram
    participant Node1
    participant Node2
    participant Node3
    participant ClusterMembership
    participant MessageReceiver
    participant MessageSender
    
    Note over Node1,Node3: Application Startup
    
    Node1->>ClusterMembership: Initialize
    Node2->>ClusterMembership: Initialize
    Node3->>ClusterMembership: Initialize
    
    ClusterMembership->>ClusterMembership: Load Static Peers
    ClusterMembership->>MessageSender: Connect to Peer (Node2)
    ClusterMembership->>MessageSender: Connect to Peer (Node3)
    
    MessageSender->>Node2: TCP Connection
    Node2->>MessageReceiver: Accept Connection
    MessageReceiver->>ClusterMembership: Register Peer (Node1)
    
    MessageSender->>Node3: TCP Connection
    Node3->>MessageReceiver: Accept Connection
    MessageReceiver->>ClusterMembership: Register Peer (Node1)
    
    Node2->>MessageSender: Connect to Peer (Node3)
    MessageSender->>Node3: TCP Connection
    Node3->>MessageReceiver: Accept Connection
    MessageReceiver->>ClusterMembership: Register Peer (Node2)
    
    Note over Node1,Node3: All Nodes Connected
    
    Node1->>ClusterMembership: Start Heartbeat
    Node2->>ClusterMembership: Start Heartbeat
    Node3->>ClusterMembership: Start Heartbeat
    
    loop Every 5 seconds
        Node1->>Node2: Heartbeat
        Node1->>Node3: Heartbeat
        Node2->>Node1: Heartbeat
        Node2->>Node3: Heartbeat
        Node3->>Node1: Heartbeat
        Node3->>Node2: Heartbeat
    end
        </div>
    </div>

    <h2 id="cache-replication">Cache Replication Sequence</h2>
    <div class="diagram-container">
        <div class="mermaid">
sequenceDiagram
    participant Writer
    participant WriterCache
    participant WriterCoordinator
    participant WriterSender
    participant Network
    participant ReaderReceiver
    participant ReaderCoordinator
    participant ReaderCache
    
    Writer->>WriterCache: put("issue", "issue:123", data)
    WriterCache->>WriterCache: Store locally
    WriterCache->>WriterCoordinator: Check replication mode
    
    alt Replication Mode: INVALIDATE
        WriterCoordinator->>WriterSender: Send InvalidationMessage
        WriterSender->>Network: Serialize & Send
        Network->>ReaderReceiver: Receive Message
        ReaderReceiver->>ReaderCoordinator: Process Invalidation
        ReaderCoordinator->>ReaderCache: invalidate("issue", "issue:123")
        ReaderCache->>ReaderCache: Remove from cache
    else Replication Mode: REPLICATE
        WriterCoordinator->>WriterSender: Send ReplicationMessage
        WriterSender->>Network: Serialize & Send
        Network->>ReaderReceiver: Receive Message
        ReaderReceiver->>ReaderCoordinator: Process Replication
        ReaderCoordinator->>ReaderCache: put("issue", "issue:123", data)
        ReaderCache->>ReaderCache: Store in cache
    else Replication Mode: NONE
        WriterCoordinator->>WriterCoordinator: Skip replication
    end
        </div>
    </div>

    <h2 id="latency">Latency Breakdown</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph LR
    subgraph "Cache Hit"
        CH1[Client Request] --> CH2[CacheService<br/>0.1ms]
        CH2 --> CH3[CacheManager<br/>0.5ms]
        CH3 --> CH4[Return Value<br/>0.4ms]
        CH4 --> CH5[Total: <2ms]
    end
    
    subgraph "Cache Miss"
        CM1[Client Request] --> CM2[CacheService<br/>0.1ms]
        CM2 --> CM3[CacheManager<br/>0.5ms]
        CM3 --> CM4[Database Query<br/>300ms]
        CM4 --> CM5[Store in Cache<br/>1ms]
        CM5 --> CM6[Return Value<br/>0.4ms]
        CM6 --> CM7[Total: ~300ms]
    end
    
    style CH5 fill:#90EE90
    style CM7 fill:#FFE4B5
        </div>
    </div>

    <h2 id="throughput">Throughput Architecture</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph TB
    subgraph "High Concurrency"
        REQ1[Request 1]
        REQ2[Request 2]
        REQ3[Request 3]
        REQN[Request N<br/>5000 req/sec]
    end
    
    subgraph "Cache Service"
        CS[CacheService<br/>Thread-Safe]
        LOCKS[Per-Key Locks<br/>ConcurrentHashMap]
    end
    
    subgraph "Storage"
        CACHE[ConcurrentHashMap<br/>Lock-Free Reads]
    end
    
    REQ1 --> CS
    REQ2 --> CS
    REQ3 --> CS
    REQN --> CS
    
    CS --> LOCKS
    CS --> CACHE
    
    style CS fill:#90EE90
    style CACHE fill:#FFE4B5
        </div>
    </div>

    <h2 id="security">Security Layers</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph TB
    subgraph "External"
        CLIENT[Client Request]
    end
    
    subgraph "Security Layer"
        AUTH[Basic Authentication<br/>Spring Security]
        VALIDATE[Input Validation<br/>@Valid Annotations]
        RATE[Rate Limiting<br/>Future Enhancement]
    end
    
    subgraph "Application Layer"
        CONTROLLER[REST Controllers]
        SERVICE[Cache Service]
    end
    
    CLIENT --> AUTH
    AUTH -->|Authenticated| VALIDATE
    VALIDATE -->|Valid| CONTROLLER
    CONTROLLER --> SERVICE
    
    style AUTH fill:#FF6B6B
    style VALIDATE fill:#FFE66D
    style CONTROLLER fill:#90EE90
        </div>
    </div>

    <h2 id="metrics">Metrics Flow</h2>
    <div class="diagram-container">
        <div class="mermaid">
graph LR
    subgraph "Application"
        CS[CacheService]
        CM[CacheManager]
        CC[ClusterCoordinator]
    end
    
    subgraph "Metrics Collection"
        METRICS[CacheMetrics<br/>Micrometer]
        COUNTERS[Counters<br/>Hits, Misses]
        TIMERS[Timers<br/>Load Time]
        GAUGES[Gauges<br/>Size, Memory]
    end
    
    subgraph "Export"
        ACTUATOR[Spring Actuator<br/>/actuator/metrics]
        PROMETHEUS[Prometheus<br/>/actuator/prometheus]
    end
    
    subgraph "Visualization"
        GRAFANA[Grafana<br/>Dashboards]
        ALERTS[AlertManager<br/>Alerts]
    end
    
    CS --> METRICS
    CM --> METRICS
    CC --> METRICS
    
    METRICS --> COUNTERS
    METRICS --> TIMERS
    METRICS --> GAUGES
    
    COUNTERS --> ACTUATOR
    TIMERS --> ACTUATOR
    GAUGES --> ACTUATOR
    
    ACTUATOR --> PROMETHEUS
    PROMETHEUS --> GRAFANA
    PROMETHEUS --> ALERTS
        </div>
    </div>

    <div class="note" style="margin-top: 40px;">
        <strong>‚úÖ All diagrams rendered!</strong> If you see visual diagrams above, Mermaid is working correctly.
        <br><br>
        <strong>Note:</strong> This HTML file uses Mermaid.js CDN to render diagrams. 
        You need an internet connection for the diagrams to load.
    </div>

</body>
</html>

